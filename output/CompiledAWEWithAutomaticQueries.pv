(* Protocol: AccountableWarrantExecution *)

free c: channel.

fun Left(bitstring): bitstring [data].
fun Right(bitstring): bitstring [data].

type bytes.
type pkey.
type skey.
type mpkeyi.
type mskeyi.
type skeyi.
type rand.

fun PKIBEFORM(mpkeyi): bitstring [data].
fun PKFORM(pkey): bitstring [data].

fun OK(): bytes.
fun pk(skey): pkey.
fun enc(pkey, bytes, rand): bytes.
fun dec(skey, bytes): bytes.
fun sign(skey, bytes): bytes.
fun checksign(bytes, pkey): bytes.
fun pkibe(mskeyi): mpkeyi.
fun encibe(mpkeyi, bytes, bytes): bytes.
fun extract(mskeyi, bytes): skeyi.
fun decibe(bytes, skeyi): bytes.
fun blind(bytes, rand): bytes.
fun pextract(mskeyi, bytes): bytes.
fun bextract(rand, bytes): skeyi.
fun pzk(bytes, rand): bytes.
fun checkzkpok(bytes, bytes): bytes.
fun pzkenc(bytes, rand): bytes.
fun checkzkpokenc(bytes, bytes): bytes.
fun encwrap(bytes, rand): bytes.
fun encunwrap(bytes): bitstring.
fun signwrap(bytes, bytes, bytes): bytes.
fun signunwrap(bytes): bitstring.

equation forall k: skey, m: bytes, r: rand;
	dec(k, enc(pk(k), m, r)) = m.
equation forall m: bytes, ssk: skey;
	checksign(sign(ssk, m), pk(ssk)) = m.
equation forall idi: bytes, m: bytes, msk: mskeyi;
	decibe(encibe(pkibe(msk), idi, m), extract(msk, idi)) = m.
equation forall idi: bytes, msk: mskeyi, r: rand;
	bextract(r, pextract(msk, blind(idi, r))) = extract(msk, idi).
equation forall idi: bytes, r: rand;
	checkzkpok(blind(idi, r), pzk(idi, r)) = OK().
equation forall idi: bytes, r: rand, sk: skey;
	checkzkpokenc(enc(pk(sk), idi, r), pzkenc(idi, r)) = OK().
equation forall id: bytes, r: rand;
	encunwrap(encwrap(id, r)) = (id, r).
equation forall a: bytes, c: bytes, z: bytes;
	signunwrap(signwrap(a, c, z)) = (a, c, z).

event OkCourt().
event OKaud(bytes).
event KOaud(bytes).
event OKdec(bytes).

query event(OkCourt()).
query k: skey, r: rand;
	event(OKaud(enc(pk(k), OK(), r))).
query idi: bytes;
	event(KOaud(idi)).
query ctc: bytes;
	event(OKdec(ctc)).

let CourtB1(c_CourtSource_authconf: channel, c_CourtDecryptor_authconf: channel, c_AuditorCourt_authconf: channel, ct: bytes, pka: pkey, skc: skey, id: bytes) =
	new r: rand;
	let ctc = enc(pka, id, r) in
	let signed_ctc = sign(skc, ctc) in
	out(c_AuditorCourt_authconf, signed_ctc);
	new r2: rand;
	let audit = enc(pka, encwrap(id, r), r2) in
	let signed_audit = sign(skc, audit) in
	let b = blind(id, r) in
	out(c_CourtDecryptor_authconf, (b, pzk(id, r), signed_ctc, signed_audit, pzkenc(id, r)));
	in(c_CourtDecryptor_authconf, partial: bytes);
	let sk = bextract(r, partial) in
	let m = decibe(ct, sk) in
	event OkCourt();
	0.

let JudgeB1() =
	0.

let Source(c_CourtSource_authconf: channel, mpk: mpkeyi, id: bytes, msg: bytes) = 
	out(c, PKIBEFORM(mpk));
	let ct = encibe(mpk, id, msg) in
	out(c_CourtSource_authconf, ct);
	out(c, ct);
	0.

let Court(c_CourtSource_authconf: channel, c_CourtDecryptor_authconf: channel, c_AuditorCourt_authconf: channel, pka: pkey, skc: skey, id: bytes) = 
	out(c, PKFORM(pka));
	in(c_CourtSource_authconf, ct: bytes);
	in(c, branchchoice: bitstring);
	(
		let Left(leftbr) = branchchoice in
		CourtB1(c_CourtSource_authconf, c_CourtDecryptor_authconf, c_AuditorCourt_authconf, ct, pka, skc, id)
	)
	|
	(
		let Right(rightbr) = branchchoice in
		0
	).

let Decryptor(c_CourtDecryptor_authconf: channel, c_AuditorDecryptor_authconf: channel, pkc: pkey, skd: skey, msk: mskeyi) = 
	out(c, PKFORM(pkc));
	in(c_CourtDecryptor_authconf, drequest: bitstring);
	let (b: bytes, pzk: bytes, signed_ctc: bytes, signed_audit: bytes, pzkenc: bytes) = drequest in
	let ctc = checksign(signed_ctc, pkc) in
	let audit = checksign(signed_audit, pkc) in
	new p: bytes;
	let partial = ( if(checkzkpokenc(ctc, pzkenc) = OK() && checkzkpok(b, pzk) = OK()) then pextract(msk, b) else p ) in
	let dsign = sign(skd, signwrap(audit, ctc, pzkenc)) in
	out(c_CourtDecryptor_authconf, partial);
	out(c_AuditorDecryptor_authconf, dsign);
	0.

let Auditor(c_AuditorDecryptor_authconf: channel, c_AuditorCourt_authconf: channel, pkd: pkey, pkc: pkey, ska: skey) = 
	out(c, PKFORM(pkd));
	in(c_AuditorCourt_authconf, ctcsign: bytes);
	in(c_AuditorDecryptor_authconf, dsign: bytes);
	out(c, (ctcsign, dsign));
	let ctc = checksign(ctcsign, pkc) in
	let id_ctc = dec(ska, ctc) in
	let (audit: bytes, ctcd: bytes, zkenc: bytes) = signunwrap(checksign(dsign, pkd)) in
	let (id_audit: bytes, r: rand) = encunwrap(dec(ska, audit)) in
	out(c, (audit, ctcd, zkenc));
	0.

let Judge() = 
	in(c, branchchoice: bitstring);
	(
		let Left(leftbr) = branchchoice in
		JudgeB1()
	)
	|
	(
		let Right(rightbr) = branchchoice in
		0
	).

let Public() = 
	in(c, mpkform: bitstring);
	in(c, pkaform: bitstring);
	in(c, pkcform: bitstring);
	in(c, pkdform: bitstring);
	in(c, ct: bytes);
	in(c, auditableproof1: bitstring);
	in(c, auditableproof2: bitstring);
	0.

process (
	new c_AuditorCourt_authconf: channel;
	new c_AuditorDecryptor_authconf: channel;
	new c_CourtDecryptor_authconf: channel;
	new c_CourtSource_authconf: channel;
	new id: bytes;
	new msg: bytes;
	new msk: mskeyi;
	new ska: skey;
	new skc: skey;
	new skd: skey;
	let pkd = pk(skd) in
	let pkc = pk(skc) in
	let pka = pk(ska) in
	let mpk = pkibe(msk) in

	Source(c_CourtSource_authconf, mpk, id, msg) |
	Court(c_CourtSource_authconf, c_CourtDecryptor_authconf, c_AuditorCourt_authconf, pka, skc, id) |
	Decryptor(c_CourtDecryptor_authconf, c_AuditorDecryptor_authconf, pkc, skd, msk) |
	Auditor(c_AuditorDecryptor_authconf, c_AuditorCourt_authconf, pkd, pkc, ska) |
	Judge() |
	Public()
)