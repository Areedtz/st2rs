(* Protocol: NeedhamSchroeder *)

free c: channel.

fun Left(bitstring): bitstring [data].
fun Right(bitstring): bitstring [data].

type bytes.
type skey.
type pkey.

fun pk(skey): pkey.
fun aenc(pkey, bytes): bytes.
fun adec(skey, bytes): bytes.
fun nawrap(pkey, bytes): bytes.
fun naunwrap(bytes): bitstring.
fun nanbwrap(pkey, bytes, bytes): bytes.
fun nanbunwrap(bytes): bitstring.

equation forall k: skey, m: bytes;
	adec(k, aenc(pk(k), m)) = m.
equation forall nonce: bytes, pk: pkey;
	naunwrap(nawrap(pk, nonce)) = (pk, nonce).
equation forall nonce1: bytes, nonce2: bytes, pk: pkey;
	nanbunwrap(nanbwrap(pk, nonce1, nonce2)) = (pk, nonce1, nonce2).

event start_a(pkey, pkey, bytes).
event mid_a(pkey, pkey, bytes, bytes).
event end_a(pkey, pkey, bytes, bytes).
event start_b(pkey, pkey, bytes, bytes).
event end_b(pkey, pkey, bytes, bytes).

query na: bytes, pka: pkey, pkb: pkey;
	event(start_a(pka, pkb, na)).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	event(mid_a(pka, pkb, na, nb)).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	event(end_a(pka, pkb, na, nb)).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	event(start_b(pka, pkb, na, nb)).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	event(end_b(pka, pkb, na, nb)).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	(event(end_a(pka, pkb, na, nb)) ==> event(start_b(pka, pkb, na, nb))).
query na: bytes, nb: bytes, pka: pkey, pkb: pkey;
	(inj-event(end_a(pka, pkb, na, nb)) ==> inj-event(start_b(pka, pkb, na, nb))).

let AI(enc_nb: bytes) =
	out(c, enc_nb);
	0.

let A(pkb: pkey, ska: skey) = 
	new na: bytes;
	event start_a(pk(ska), pkb, na);
	let ct = aenc(pkb, nawrap(pk(ska), na)) in
	out(c, ct);
	in(c, ctb: bytes);
	let (=pkb, x_na: bytes, x_nb: bytes) = nanbunwrap(adec(ska, ctb)) in
	event mid_a(pk(ska), pkb, x_na, x_nb);
	new enc_nb: bytes;
	if x_na = na then
		let enc_nb = aenc(pkb, x_nb) in
		event end_a(pk(ska), pkb, x_na, x_nb);
		AI(enc_nb)
	else
		AI(enc_nb).

let B(pka: pkey, skb: skey) = 
	in(c, cta: bytes);
	let (=pka, na: bytes) = naunwrap(adec(skb, cta)) in
	new nb: bytes;
	event start_b(pka, pk(skb), na, nb);
	let ct = aenc(pka, nanbwrap(pk(skb), na, nb)) in
	out(c, ct);
	in(c, z: bytes);
	let z_nb = adec(skb, z) in
	if z_nb = nb then
		event end_b(pka, pk(skb), na, nb);
		0.

process (
	new ska: skey;
	new skb: skey;
	let pkb = pk(skb) in
	let pka = pk(ska) in

	A(pkb, ska) |
	B(pka, skb)
)