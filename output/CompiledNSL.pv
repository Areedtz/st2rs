(* Protocol: NeedhamSchroederLowe *)

free c: channel.

fun Left(bitstring): bitstring [data].
fun Right(bitstring): bitstring [data].

type id.
type bytes.
type skey.
type pkey.

fun pk(skey): pkey.
fun aenc(pkey, bytes): bytes.
fun adec(skey, bytes): bytes.
fun nawrap(id, bytes): bytes.
fun naunwrap(bytes): bitstring.
fun nanbwrap(id, bytes, bytes): bytes.
fun nanbunwrap(bytes): bitstring.

equation forall k: skey, m: bytes;
	adec(k, aenc(pk(k), m)) = m.
equation forall idp: id, nonce: bytes;
	naunwrap(nawrap(idp, nonce)) = (idp, nonce).
equation forall idp: id, nonce1: bytes, nonce2: bytes;
	nanbunwrap(nanbwrap(idp, nonce1, nonce2)) = (idp, nonce1, nonce2).

event start_a(id, id, bytes).
event mid_a(id, id, bytes, bytes).
event end_a(id, id, bytes, bytes).
event start_b(id, id, bytes, bytes).
event end_b(id, id, bytes, bytes).

query ida: id, idb: id, na: bytes;
	event(start_a(ida, idb, na)).
query ida: id, idb: id, na: bytes, nb: bytes;
	event(mid_a(ida, idb, na, nb)).
query ida: id, idb: id, na: bytes, nb: bytes;
	event(end_a(ida, idb, na, nb)).
query ida: id, idb: id, na: bytes, nb: bytes;
	event(start_b(ida, idb, na, nb)).
query ida: id, idb: id, na: bytes, nb: bytes;
	event(end_b(ida, idb, na, nb)).
query ida: id, idb: id, na: bytes, nb: bytes;
	(event(end_a(ida, idb, na, nb)) ==> event(start_b(ida, idb, na, nb))).
query ida: id, idb: id, na: bytes, nb: bytes;
	(event(end_b(ida, idb, na, nb)) ==> event(start_a(ida, idb, na))).

let AI(enc_nb: bytes) =
	out(c, enc_nb);
	0.

let A(ska: skey, idb: id, ida: id) = 
	in(c, pkx: pkey);
	new na: bytes;
	event start_a(ida, idb, na);
	let ct = aenc(pkx, nawrap(ida, na)) in
	out(c, ct);
	in(c, ctb: bytes);
	let (=idb, x_na: bytes, x_nb: bytes) = nanbunwrap(adec(ska, ctb)) in
	event mid_a(ida, idb, x_na, x_nb);
	new enc_nb: bytes;
	if x_na = na then
		let enc_nb = aenc(pkx, x_nb) in
		event end_a(ida, idb, x_na, x_nb);
		AI(enc_nb)
	else
		AI(enc_nb).

let B(pka: pkey, skb: skey, ida: id, idb: id) = 
	in(c, cta: bytes);
	let (=ida, na: bytes) = naunwrap(adec(skb, cta)) in
	new nb: bytes;
	event start_b(ida, idb, na, nb);
	let ct = aenc(pka, nanbwrap(idb, na, nb)) in
	out(c, ct);
	in(c, z: bytes);
	let z_nb = adec(skb, z) in
	if z_nb = nb then
		event end_b(ida, idb, na, nb);
		0.

let Public(pkb: pkey, pka: pkey) = 
	out(c, pkb);
	0.

process (
	new ida: id;
	new idb: id;
	new ska: skey;
	new skb: skey;
	let pkb = pk(skb) in
	let pka = pk(ska) in

	A(ska, idb, ida) |
	B(pka, skb, ida, idb) |
	Public(pkb, pka)
)