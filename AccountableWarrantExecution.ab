Problem: AccountableWarrantExecution;
Principals: Source, Investigator, Decryptor, Log;
Knowledge: msk:skeyibe@Decryptor, 
           uid:id@Investigator, 
           uid:id@Source, 
           msk:skeyibe@Source,
           isk:skey@Investigator,
           isk:skey@Decryptor;
Types: skeyibe, pkeyibe, skey, pkey, id;
Functions: pk(skey) -> pkey,
           extract(skeyibe, id) -> skey,
           pkibe(skeyibe) -> pkeyibe,
           encibe(pkeyibe, id, bitstring) -> bitstring,
           decibe(bitstring, skey) -> bitstring,
           blind(id) -> bitstring,
           blindextract(skeyibe, bitstring) -> skey,
           sign(skey, bitstring) -> bitstring,
           checksign(pkey, bitstring) -> bitstring,
           pzkp(id, skey, bitstring) -> bitstring,
           checkzkp(pkey, bitstring, bitstring) -> bitstring,
           OK() -> bitstring;
Equations: decibe(encibe(mpk, uid, msg), extract(msk, uid)) = msg,
           blindextract(msk, blind(uid)) = extract(msk, uid),
           checksign(pk(sk), sign(sk, x)) = x,
           checkzkp(pk(sk), blind(uid), pzkp(uid, sk, sign(sk, blind(uid)))) = OK();
Formats: M1(bitstring),
         M2(bitstring, bitstring),
         M3(bitstring),
         M4(bitstring),
         M5(skey);
Protocol:
Source {
    new msg: bitstring;
    let ct = encibe(pkibe(msk), uid, msg);
}
Source -> Investigator: x = M1<ct>
Investigator {
    let M1<ct> = x;
    let blindid = blind(uid);
    let signedid = sign(isk, blindid);
    let zkp = pzkp(uid, isk, signedid);
}
Investigator -> Log: x = M2<signedid, zkp>
Investigator -> Decryptor: x = M3<blindid>
Log {
    let M2<signedid, zkp> = x;
}
Log -> Decryptor: y = M4<zkp>
Decryptor {
    let M3<blindid> = x;
    let M4<zkp> = y;
    if (checkzkp(pk(isk), blindid, zkp) = OK) {
        let sk = blindextract(msk, blindid);
    }
}
Decryptor -> Investigator: z = M5<sk>
Investigator {
    let M5<sk> = z;
    let msg = decibe(ct, sk);
}
end
