Problem: AccountableWarrantExecution;
Principals: Source, Court, Decryptor, Auditor, KeyDistributor, Public;
Knowledge: msg:bitstring@Source, 
           id:bitstring@Source,
           id:bitstring@Court;
Types: pkey, skey, mpkeyi, mskeyi, skeyi, rand;
Functions: OK() -> bitstring,
           pk(skey) -> pkey,
           enc(pkey, bitstring, rand) -> bitstring,
           dec(skey, bitstring) -> bitstring,
           sign(skey, bitstring) -> bitstring,
           checksign(bitstring, pkey) -> bitstring,
           pkibe(mskeyi) -> mpkeyi,
           encibe(mpkeyi, bitstring, bitstring) -> bitstring,
           extract(mskeyi, bitstring) -> skeyi,
           decibe(bitstring, skeyi) -> bitstring,
           blind(bitstring, rand) -> bitstring,
           pextract(mskeyi, bitstring) -> bitstring,
           bextract(rand, bitstring) -> skeyi,
           pzk(bitstring, rand) -> bitstring,
           checkzkpok(bitstring, bitstring) -> bitstring,
           pzkenc(bitstring, rand) -> bitstring,
           checkzkpokenc(bitstring, bitstring) -> bitstring; 
Equations: dec(k, enc(pk(k), m, r)) = m,
           checksign(sign(ssk, m), pk(ssk)) = m,
           decibe(encibe(pkibe(msk), idi, m), extract(msk, idi)) = m,
           bextract(r, pextract(msk, blind(idi, r))) = extract(msk, idi),
           checkzkpok(blind(idi, r), pzk(idi, r)) = OK,
           checkzkpokenc(enc(pk(sk), idi, r), pzkenc(idi, r)) = OK;
Formats: SKIBEFORM(mskeyi), PKIBEFORM(mpkeyi), PKFORM(pkey), PK2FORM(pkey, pkey), SKFORM(skey);
Protocol:
KeyDistributor {
    new msk: mskeyi;
    new ska: skey;
    new skc: skey;
    new skd: skey;
    let mpk = pkibe(msk);
    let pka = pk(ska);
    let pkc = pk(skc);
    let pkd = pk(skd);
}
KeyDistributor *->* Auditor: skaform = SKFORM<ska>
KeyDistributor *->* Auditor: pkcdform = PK2FORM<pkc, pkd>

KeyDistributor *->* Court: skcform = SKFORM<skc>
KeyDistributor *->* Court: pkaform = PKFORM<pka>

KeyDistributor *->* Decryptor: mskform = SKIBEFORM<msk>
KeyDistributor *->* Decryptor: skdform = SKFORM<skd>
KeyDistributor *->* Decryptor: pkcform = PKFORM<pkc>

KeyDistributor *->* Source: mpkform = PKIBEFORM<mpk>

KeyDistributor -> Public: mpkform = PKIBEFORM<mpk>
KeyDistributor -> Public: pkaform = PKFORM<pka>
KeyDistributor -> Public: pkcform = PKFORM<pkc>
KeyDistributor -> Public: pkdform = PKFORM<pkd>

Source {
    let PKIBEFORM<mpk> = mpkform;
    let ct = encibe(mpk, id, msg);
}
Source *->* Court: ct = ct
Source -> Public: ct = ct
Court {
    let SKFORM<skc> = skcform;
    let PKFORM<pka> = pkaform;
    new r: rand;
    let ctc = enc(pka, id, r);
    let signed_ctc = sign(skc, ctc);
}
Court *->* Auditor: ctcsign = signed_ctc
Court {
    new r2: rand;
    let audit = enc(pka, <id, r>, r2);
    let signed_audit = sign(skc, audit);
    let b = blind(id, r);
}
Court *->* Decryptor: drequest = <b, pzk(id, r), signed_ctc, signed_audit, pzkenc(id, r)>
Decryptor {
    let SKIBEFORM<msk> = mskform;
    let SKFORM<skd> = skdform;
    let PKFORM<pkc> = pkcform;
    let <b: bitstring, pzk: bitstring, signed_ctc: bitstring, signed_audit: bitstring, pzkenc: bitstring> = drequest;
    let ctc = checksign(signed_ctc, pkc);
    let audit = checksign(signed_audit, pkc);
    new p': bitstring;
    let partial = if(checkzkpokenc(ctc, pzkenc) = OK & checkzkpok(b, pzk) = OK, pextract(msk, b), p');
    let dsign = sign(skd, <audit, ctc, pzkenc>);
}
Decryptor *->* Court: partial = partial
Decryptor *->* Auditor: dsign = dsign
Court {
    let sk = bextract(r, partial);
    let m = decibe(ct, sk);
}
Auditor -> Public: auditableproof1 = <ctcsign, dsign>
Auditor {
    let SKFORM<ska> = skaform;
    let PK2FORM<pkc, pkd> = pkcdform;
    let ctc = checksign(ctcsign, pkc);
    let id_ctc = dec(ska, ctc);
    let <audit: bitstring, ctcd: bitstring, zkenc: bitstring> = checksign(dsign, pkd);
    let <id_audit: bitstring, r: rand> = dec(ska, audit);
}
Auditor -> Public: auditableproof2 = <audit, ctcd, zkenc>
end
