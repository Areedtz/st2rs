Problem: AccountableWarrantExecution;
Principals: Source, Investigator, Decryptor, Log, Public;
Knowledge: msk:skeyibe@Decryptor, 
           uid:id@Investigator, 
           uid:id@Source, 
           mpk:pkeyibe@Source,
           isk:skey@Investigator,
           isk:skey@Decryptor;
Types: skeyibe, pkeyibe, skey, pkey, id, rand;
Functions: pk(skey) -> pkey,
           pkibe(skeyibe) -> pkeyibe,
           encibe(pkeyibe, id, bitstring) -> bitstring,
           decibe(bitstring, skey) -> bitstring,
           blind(id, rand) -> bitstring,
           partialextract(skeyibe, bitstring) -> bitstring,
           blindextract(rand, bitstring) -> skey,
           extract(skeyibe, id) -> skey,
           sign(skey, bitstring) -> bitstring,
           checksign(pkey, bitstring) -> bitstring,
           pzkp(id, skey, bitstring) -> bitstring,
           checkzkp(pkey, bitstring, bitstring) -> bitstring,
           OK() -> bitstring;
Equations: decibe(encibe(pkibe(msk), uid, msg), extract(msk, uid)) = msg,
           blindextract(r, partialextract(msk, blind(uid, r))) = extract(msk, uid),
           checksign(pk(sk), sign(sk, x)) = x,
           checkzkp(pk(sk), blind(uid, r), pzkp(uid, sk, sign(sk, blind(uid, r)))) = OK;
Formats: M1(bitstring),
         M2(bitstring, bitstring),
         M3(bitstring),
         M4(bitstring),
         M5(bitstring);
Protocol:
Source {
    new msg: bitstring;
    let ct = encibe(mpk, uid, msg);
}
Source *->* Investigator: x = M1<ct>
Source -> Public: ct = ct
Investigator {
    let M1<ct> = x;
    new r: rand;
    let blindid = blind(uid, r);
    let signedid = sign(isk, blindid);
    let zkp = pzkp(uid, isk, signedid);
}
Investigator *->* Log: x = M2<signedid, zkp>
Investigator *->* Decryptor: x = M3<blindid>
Log {
    let M2<signedid, zkp> = x;
}
Log -> Decryptor: y = M4<zkp>
Decryptor {
    let M3<blindid> = x;
    let M4<zkp> = y;
    new sk': bitstring;
    let psk = if(checkzkp(pk(isk), blindid, zkp) = OK, partialextract(msk, blindid), sk');
}
Decryptor *->* Investigator: z = M5<psk>
Investigator {
    let M5<psk> = z;
    let sk = blindextract(r, psk);
    let msg = decibe(ct, sk);
}
end