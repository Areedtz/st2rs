(* Protocol: AccountableWarrantExecution *)
(* Test for correctness *)

free c: channel.

type pkey.
type skey.
type mpkeyi.
type mskeyi.
type skeyi.
type rand.

(* 
	Free variables, id and msg, had to be
	added manually, as this isn't possible
	in the AB syntax and compiler yet.
	They are needed to check if the
	attacker gains knowledge of them.
*)
free id: bitstring [private].
free msg: bitstring [private].

(* 
	Format functions are needed since 
	compiler currently only expects 
	bitstrings/tuples over channels.
*)
fun SKIBEFORM(mskeyi): bitstring [data].
fun PKIBEFORM(mpkeyi): bitstring [data].
fun PKFORM(pkey): bitstring [data].
fun SKFORM(skey): bitstring [data].

fun OK(): bitstring.

(* Probalistic encryption *)
fun pk(skey): pkey.
fun enc(pkey, bitstring, rand): bitstring.
fun dec(skey, bitstring): bitstring.

(* Signatures *)
fun sign(skey, bitstring): bitstring.
fun checksign(bitstring, pkey): bitstring.

(* IBE *)
fun pkibe(mskeyi): mpkeyi.
fun encibe(mpkeyi, bitstring, bitstring): bitstring.
fun extract(mskeyi, bitstring): skeyi.
fun decibe(bitstring, skeyi): bitstring.
fun blind(bitstring, rand): bitstring.
fun pextract(mskeyi, bitstring): bitstring.
fun bextract(rand, bitstring): skeyi.

(* ZKP for Blinded ID *)
fun pzk(bitstring, rand): bitstring.
fun checkzkpok(bitstring, bitstring): bitstring.

(* ZKP for encryption *)
fun pzkenc(bitstring, rand): bitstring.
fun checkzkpokenc(bitstring, bitstring): bitstring.

equation forall k: skey, m: bitstring, r: rand;
	dec(k, enc(pk(k), m, r)) = m.
equation forall m: bitstring, ssk: skey;
	checksign(sign(ssk, m), pk(ssk)) = m.
equation forall idi: bitstring, m: bitstring, msk: mskeyi;
	decibe(encibe(pkibe(msk), idi, m), extract(msk, idi)) = m.
equation forall idi: bitstring, msk: mskeyi, r: rand;
	bextract(r, pextract(msk, blind(idi, r))) = extract(msk, idi).
equation forall idi: bitstring, r: rand;
	checkzkpok(blind(idi, r), pzk(idi, r)) = OK.
equation forall idi: bitstring, r: rand, sk: skey;
	checkzkpokenc(enc(pk(sk), idi, r), pzkenc(idi, r)) = OK.

(*
	Events are added manually as 
	compiler doesn't support them yet.
*)
event OKcourt().
event OKaud(bitstring).
event KOaud(bitstring).

query event (OKcourt()).
query idi: bitstring; event (OKaud(idi)).
query idi: bitstring; event (KOaud(idi)).

query attacker(id).
query attacker(msg).

event OKdec(bitstring).
query ctc: bitstring; event (OKdec(ctc)).

let Source(c_KeyDistributorSource_authconf: channel, c_CourtSource_authconf: channel) = 
	in(c_KeyDistributorSource_authconf, mpkform: bitstring);
	let PKIBEFORM(mpk) = mpkform in
	let ct = encibe(mpk, id, msg) in
	out(c_CourtSource_authconf, ct);
	out(c, ct);
	0.

let Court(c_CourtSource_authconf: channel, c_CourtKeyDistributor_authconf: channel, c_CourtDecryptor_authconf: channel, c_AuditorCourt_authconf: channel) = 
	in(c_CourtKeyDistributor_authconf, skcform: bitstring);
	in(c_CourtKeyDistributor_authconf, pkaform: bitstring);
	in(c_CourtSource_authconf, ct: bitstring);
	let SKFORM(skc) = skcform in
	let PKFORM(pka) = pkaform in
	new r: rand;
	let ctc = enc(pka, id, r) in
	let signed_ctc = sign(skc, ctc) in
	out(c_AuditorCourt_authconf, signed_ctc);
	new r2: rand;
	let audit = enc(pka, (id, r), r2) in
	let signed_audit = sign(skc, audit) in
	let b = blind(id, r) in
	out(c_CourtDecryptor_authconf, (b, pzk(id, r), signed_ctc, signed_audit, pzkenc(id, r)));
	in(c_CourtDecryptor_authconf, partial: bitstring);
	let sk = bextract(r, partial) in
	let m = decibe(ct, sk) in
	event OKcourt.

let Decryptor(c_DecryptorKeyDistributor_authconf: channel, c_CourtDecryptor_authconf: channel, c_AuditorDecryptor_authconf: channel) = 
	in(c_DecryptorKeyDistributor_authconf, mskform: bitstring);
	in(c_DecryptorKeyDistributor_authconf, skdform: bitstring);
	in(c_DecryptorKeyDistributor_authconf, pkcform: bitstring);
	in(c_CourtDecryptor_authconf, drequest: bitstring);
	let SKIBEFORM(msk) = mskform in
	let SKFORM(skd) = skdform in
	let PKFORM(pkc) = pkcform in
	let (b: bitstring, pzk: bitstring, signed_ctc: bitstring, signed_audit: bitstring, pzkenc: bitstring) = drequest in
	let ctc = checksign(signed_ctc, pkc) in
	let audit = checksign(signed_audit, pkc) in
	(*
		Compiler currently only supports
		if assignments, so to implement an
		if statement in this way, we assign
		a random bitstring, if the conditions fail.
	*)
	new p': bitstring;
	let partial = ( if(checkzkpokenc(ctc, pzkenc) = OK && checkzkpok(b, pzk) = OK) then pextract(msk, b) else p' ) in
	let dsign = sign(skd, (audit, ctc, pzkenc)) in
	out(c_CourtDecryptor_authconf, partial);
	out(c_AuditorDecryptor_authconf, dsign);
	(* Event only fires if conditions didn't fail *)
	if not(partial = p') then
	    event OKdec(ctc).

let Auditor(c_AuditorKeyDistributor_authconf: channel, c_AuditorDecryptor_authconf: channel, c_AuditorCourt_authconf: channel) = 
	in(c_AuditorKeyDistributor_authconf, skaform: bitstring);
	in(c_AuditorKeyDistributor_authconf, pkcd: bitstring);
	in(c_AuditorCourt_authconf, ctcsign: bitstring);
	in(c_AuditorDecryptor_authconf, dsign: bitstring);
	out(c, (ctcsign, dsign));
	let SKFORM(ska) = skaform in
	let (pkc: pkey, pkd: pkey) = pkcd in
	let ctc = checksign(ctcsign, pkc) in
	let id_ctc = dec(ska, ctc) in
	let (audit: bitstring, ctcd: bitstring, zkenc: bitstring) = checksign(dsign, pkd) in
	let (id_audit: bitstring, r: rand) = dec(ska, audit) in
	out(c, (audit, ctcd, zkenc));
	if id_ctc=id_audit then
		event OKaud(id)
	else event KOaud(id).

(* 
	We need a key distributor principal to 
	distribute the keys among the principals,
	since the compiler currently doesn't support
	knowledge of public keys and receiving public
	keys from a public channel will break correctness.

	Example on the kind of syntax that knowledge would
	need to support to give principals public keys in main process:
	pka=pk(ska)@Court
	which would mean that a variable pka, which is created with pk(ska)
	should be given to the Court principal.
*)
let KeyDistributor(c_KeyDistributorSource_authconf: channel, c_DecryptorKeyDistributor_authconf: channel, c_CourtKeyDistributor_authconf: channel, c_AuditorKeyDistributor_authconf: channel) = 
	new msk: mskeyi;
	new ska: skey;
	new skc: skey;
	new skd: skey;
	let mpk = pkibe(msk) in
	let pka = pk(ska) in
	let pkc = pk(skc) in
	let pkd = pk(skd) in
	out(c_AuditorKeyDistributor_authconf, SKFORM(ska));
	out(c_AuditorKeyDistributor_authconf, (pkc, pkd));
	out(c_CourtKeyDistributor_authconf, SKFORM(skc));
	out(c_CourtKeyDistributor_authconf, PKFORM(pka));
	out(c_DecryptorKeyDistributor_authconf, SKIBEFORM(msk));
	out(c_DecryptorKeyDistributor_authconf, SKFORM(skd));
	out(c_DecryptorKeyDistributor_authconf, PKFORM(pkc));
	out(c_KeyDistributorSource_authconf, PKIBEFORM(mpk));
	out(c, PKIBEFORM(mpk));
	out(c, PKFORM(pka));
	out(c, PKFORM(pkc));
	out(c, PKFORM(pkd));
	0.

(*
	The public process is there to allow
	principals to publish something on a public
	channel, without having to send it to
	another principal as well.
	Again a limitation of the AB syntax and compiler.
*)
let Public() = 
	in(c, mpkform: bitstring);
	in(c, pkaform: bitstring);
	in(c, pkcform: bitstring);
	in(c, pkdform: bitstring);
	in(c, ct: bitstring);
	in(c, something: bitstring);
	in(c, somethingelse: bitstring);
	0.

process (
	new c_AuditorCourt_authconf: channel;
	new c_AuditorDecryptor_authconf: channel;
	new c_AuditorKeyDistributor_authconf: channel;
	new c_CourtDecryptor_authconf: channel;
	new c_CourtKeyDistributor_authconf: channel;
	new c_CourtSource_authconf: channel;
	new c_DecryptorKeyDistributor_authconf: channel;
	new c_KeyDistributorSource_authconf: channel;
	Source(c_KeyDistributorSource_authconf, c_CourtSource_authconf) | Court(c_CourtSource_authconf, c_CourtKeyDistributor_authconf, c_CourtDecryptor_authconf, c_AuditorCourt_authconf) | Decryptor(c_DecryptorKeyDistributor_authconf, c_CourtDecryptor_authconf, c_AuditorDecryptor_authconf) | Auditor(c_AuditorKeyDistributor_authconf, c_AuditorDecryptor_authconf, c_AuditorCourt_authconf) | KeyDistributor(c_KeyDistributorSource_authconf, c_DecryptorKeyDistributor_authconf, c_CourtKeyDistributor_authconf, c_AuditorKeyDistributor_authconf) | Public()
)