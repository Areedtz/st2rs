Problem: AccountableWarrantExecution;
Principals: Source, Court, Decryptor, Auditor, Public;
Knowledge: msg:bitstring@Source, 
           id:bitstring@Source,
           id:bitstring@Court,
           msk:mskeyi@Decryptor,
           ska:skey@Auditor,
           skc:skey@Court,
           skd:skey@Decryptor,
           mpk:mpkeyi@Source = pkibe(msk),
           pka:pkey@Court = pk(ska),
           pkc:pkey@Auditor = pk(skc),
           pkc:pkey@Decryptor = pk(skc),
           pkd:pkey@Auditor = pk(skd);
Types: pkey, skey, mpkeyi, mskeyi, skeyi, rand;
Functions: OK() -> bitstring,
           pk(skey) -> pkey,
           enc(pkey, bitstring, rand) -> bitstring,
           dec(skey, bitstring) -> bitstring,
           sign(skey, bitstring) -> bitstring,
           checksign(bitstring, pkey) -> bitstring,
           pkibe(mskeyi) -> mpkeyi,
           encibe(mpkeyi, bitstring, bitstring) -> bitstring,
           extract(mskeyi, bitstring) -> skeyi,
           decibe(bitstring, skeyi) -> bitstring,
           blind(bitstring, rand) -> bitstring,
           pextract(mskeyi, bitstring) -> bitstring,
           bextract(rand, bitstring) -> skeyi,
           pzk(bitstring, rand) -> bitstring,
           checkzkpok(bitstring, bitstring) -> bitstring,
           pzkenc(bitstring, rand) -> bitstring,
           checkzkpokenc(bitstring, bitstring) -> bitstring; 
Equations: dec(k, enc(pk(k), m, r)) = m,
           checksign(sign(ssk, m), pk(ssk)) = m,
           decibe(encibe(pkibe(msk), idi, m), extract(msk, idi)) = m,
           bextract(r, pextract(msk, blind(idi, r))) = extract(msk, idi),
           checkzkpok(blind(idi, r), pzk(idi, r)) = OK,
           checkzkpokenc(enc(pk(sk), idi, r), pzkenc(idi, r)) = OK;
Formats: PKIBEFORM(mpkeyi), PKFORM(pkey);
Protocol:
Source -> Public: mpkform = PKIBEFORM<mpk>
Court -> Public: pkaform = PKFORM<pka>
Decryptor -> Public: pkcform = PKFORM<pkc>
Auditor -> Public: pkdform = PKFORM<pkd>

Source {
    let ct = encibe(mpk, id, msg);
}
Source *->* Court: ct = ct
Source -> Public: ct = ct
Court {
    new r: rand;
    let ctc = enc(pka, id, r);
    let signed_ctc = sign(skc, ctc);
}
Court *->* Auditor: ctcsign = signed_ctc
Court {
    new r2: rand;
    let audit = enc(pka, <id, r>, r2);
    let signed_audit = sign(skc, audit);
    let b = blind(id, r);
}
Court *->* Decryptor: drequest = <b, pzk(id, r), signed_ctc, signed_audit, pzkenc(id, r)>
Decryptor {
    let <b: bitstring, pzk: bitstring, signed_ctc: bitstring, signed_audit: bitstring, pzkenc: bitstring> = drequest;
    let ctc = checksign(signed_ctc, pkc);
    let audit = checksign(signed_audit, pkc);
    new p: bitstring;
    let partial = if(checkzkpokenc(ctc, pzkenc) = OK() & checkzkpok(b, pzk) = OK(), pextract(msk, b), p);
    let dsign = sign(skd, <audit, ctc, pzkenc>);
}
Decryptor *->* Court: partial = partial
Decryptor *->* Auditor: dsign = dsign
Court {
    let sk = bextract(r, partial);
    let m = decibe(ct, sk);
}
Auditor -> Public: auditableproof1 = <ctcsign, dsign>
Auditor {
    let ctc = checksign(ctcsign, pkc);
    let id_ctc = dec(ska, ctc);
    let <audit: bitstring, ctcd: bitstring, zkenc: bitstring> = checksign(dsign, pkd);
    let <id_audit: bitstring, r: rand> = dec(ska, audit);
}
Auditor -> Public: auditableproof2 = <audit, ctcd, zkenc>
end
