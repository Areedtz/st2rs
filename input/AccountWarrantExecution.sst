Problem: AccountableWarrantExecution;
Principals: Source, Court, Decryptor, Auditor, Judge, Public;
Knowledge: msg:bytes@Source, 
           id:bytes@Source,
           id:bytes@Court,
           msk:mskeyi@Decryptor,
           ska:skey@Auditor,
           skc:skey@Court,
           skd:skey@Decryptor,
           mpk:mpkeyi@Source = pkibe(msk),
           pka:pkey@Court = pk(ska),
           pkc:pkey@Auditor = pk(skc),
           pkc:pkey@Decryptor = pk(skc),
           pkd:pkey@Auditor = pk(skd);
Types: bytes, pkey, skey, mpkeyi, mskeyi, skeyi, rand;
Functions: OK() -> bytes,
           APPROVE() -> bytes,
           REJECT() -> bytes,
           pk(skey) -> pkey,
           enc(pkey, bytes, rand) -> bytes,
           dec(skey, bytes) -> bytes,
           sign(skey, bytes) -> bytes,
           checksign(bytes, pkey) -> bytes,
           pkibe(mskeyi) -> mpkeyi,
           encibe(mpkeyi, bytes, bytes) -> bytes,
           extract(mskeyi, bytes) -> skeyi,
           decibe(bytes, skeyi) -> bytes,
           blind(bytes, rand) -> bytes,
           pextract(mskeyi, bytes) -> bytes,
           bextract(rand, bytes) -> skeyi,
           pzk(bytes, rand) -> bytes,
           checkzkpok(bytes, bytes) -> bytes,
           pzkenc(bytes, rand) -> bytes,
           checkzkpokenc(bytes, bytes) -> bytes,
           encwrap(bytes, rand) -> bytes,
           encunwrap(bytes) -> <bytes, rand>,
           signwrap(bytes, bytes, bytes) -> bytes,
           signunwrap(bytes) -> <bytes, bytes, bytes>;
Equations: dec(k, enc(pk(k), m, r)) = m,
           checksign(sign(ssk, m), pk(ssk)) = m,
           decibe(encibe(pkibe(msk), idi, m), extract(msk, idi)) = m,
           bextract(r, pextract(msk, blind(idi, r))) = extract(msk, idi),
           checkzkpok(blind(idi, r), pzk(idi, r)) = OK(),
           checkzkpokenc(enc(pk(sk), idi, r), pzkenc(idi, r)) = OK(),
           encunwrap(encwrap(id, r)) = <id, r>,
           signunwrap(signwrap(a, c, z)) = <a, c, z>;
Formats: PKIBEFORM(mpkeyi), PKFORM(pkey);
Events: OKcourt(), OKaud(bytes), KOaud(bytes), OKdec(bytes);
Queries: event(OKcourt()), 
         event(OKaud(enc(pk(k), OK(), r))), 
         event(KOaud(idi)), 
         event(OKdec(ctc)),
         event(OKaud(enc(pk(k), OK(), r))) & event(KOaud(idi));
Protocol:
Source -> Public: mpkform = PKIBEFORM<mpk>
Court -> Public: pkaform = PKFORM<pka>
Decryptor -> Public: pkcform = PKFORM<pkc>
Auditor -> Public: pkdform = PKFORM<pkd>
let G = {
    Court *->* Decryptor: status = status
    Court *->* Auditor: status = status
    Court *->* Public: status = status
    Court {
        if (status = REJECT()) {
            end
        }
    }
    Decryptor {
        if (status = REJECT()) {
            end
        }
    }
    Auditor {
        if (status = REJECT()) {
            end
        }
    }
    Public {
        if (status = REJECT()) {
            end
        }
    }
    Court {
        new r: rand;
        let ctc = enc(pka, id, r);
        let signed_ctc = sign(skc, ctc);
    }
    Court *->* Auditor: ctcsign = signed_ctc
    Court {
        new r2: rand;
        let audit = enc(pka, encwrap(id, r), r2);
        let signed_audit = sign(skc, audit);
        let b = blind(id, r);
    }
    Court *->* Decryptor: drequest = <b, pzk(id, r), signed_ctc, signed_audit, pzkenc(id, r)>
    Decryptor {
        let <b: bytes, pzk: bytes, signed_ctc: bytes, signed_audit: bytes, pzkenc: bytes> = drequest;
        let ctc = checksign(signed_ctc, pkc);
        let audit = checksign(signed_audit, pkc);
        new p: bytes;
        let partial = if((checkzkpokenc(ctc, pzkenc) = OK()) & (checkzkpok(b, pzk) = OK()), pextract(msk, b), p);
        let dsign = sign(skd, signwrap(audit, ctc, pzkenc));
    }
    Decryptor *->* Court: partial = partial
    Decryptor *->* Auditor: dsign = dsign
    Court {
        let sk = bextract(r, partial);
        let m = decibe(ct, sk);
        event OKcourt();
    }
    Auditor -> Public: auditableproof1 = <ctcsign, dsign>
    Auditor {
        let ctc = checksign(ctcsign, pkc);
        let id_ctc = dec(ska, ctc);
        let <audit: bytes, ctcd: bytes, zkenc: bytes> = signunwrap(checksign(dsign, pkd));
        let <id_audit: bytes, r: rand> = encunwrap(dec(ska, audit));
    }
    Auditor -> Public: auditableproof2 = <audit, ctcd, zkenc>
    end
} in
Source {
    let ct = encibe(mpk, id, msg);
}
Source *->* Court: ct = ct
Source -> Public: ct = ct
Court {
    let status = APPROVE(); # Set the initial status as 'approve'
}
Court -> Judge {
    Approve:
        G()
    Reject:
        Court {
            let status = REJECT();
        }
        G()
}
